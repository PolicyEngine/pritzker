#!/usr/bin/env python3
"""
Convert markdown response files to JavaScript for GitHub Pages viewer.
Includes character counts for Foundant's 10,000 character limit.
Uses pritzker_questions.yaml for question metadata.
"""

import json
import yaml
from pathlib import Path


def extract_question_and_response(markdown_content):
    """Extract question and response text separately."""
    import re

    # Look for **Question:** or ## Question pattern
    question_match = re.search(r'\*\*Question:\*\*\s*(.*?)(?=\*\*Response:\*\*|$)', markdown_content, re.DOTALL)
    response_match = re.search(r'\*\*Response:\*\*\s*(.*)', markdown_content, re.DOTALL)

    question = question_match.group(1).strip() if question_match else ''
    response = response_match.group(1).strip() if response_match else markdown_content

    return question, response


def strip_markdown_formatting(text):
    """Remove markdown formatting to get plain text for character counting."""
    import re

    # Remove headers
    text = re.sub(r'^#+\s+', '', text, flags=re.MULTILINE)

    # Remove bold/italic
    text = re.sub(r'\*\*([^*]+)\*\*', r'\1', text)
    text = re.sub(r'\*([^*]+)\*', r'\1', text)
    text = re.sub(r'__([^_]+)__', r'\1', text)
    text = re.sub(r'_([^_]+)_', r'\1', text)

    # Remove links but keep text
    text = re.sub(r'\[([^\]]+)\]\([^\)]+\)', r'\1', text)

    # Remove list markers
    text = re.sub(r'^\s*[-*+]\s+', '', text, flags=re.MULTILINE)
    text = re.sub(r'^\s*\d+\.\s+', '', text, flags=re.MULTILINE)

    # Remove code blocks
    text = re.sub(r'```[^`]*```', '', text, flags=re.DOTALL)
    text = re.sub(r'`([^`]+)`', r'\1', text)

    # Remove blockquotes
    text = re.sub(r'^>\s+', '', text, flags=re.MULTILINE)

    # Clean up extra whitespace
    text = re.sub(r'\n\n+', '\n\n', text)

    return text.strip()


def load_questions():
    """Load questions from YAML file."""
    yaml_path = Path('pritzker_questions.yaml')
    with open(yaml_path) as f:
        return yaml.safe_load(f)


def process_responses():
    """Process all response markdown files using YAML structure."""
    responses_dir = Path('responses')
    questions_data = load_questions()
    sections = questions_data.get('sections', {})
    output = {}

    for section_key, section_data in sections.items():
        filepath = responses_dir / section_data['file'].replace('responses/', '')

        if not filepath.exists():
            print(f"Warning: {filepath} not found")
            continue

        # Read markdown content
        markdown_content = filepath.read_text()

        # Extract question and response separately
        question, response = extract_question_and_response(markdown_content)

        # Get plain text version of RESPONSE ONLY for character counting and copying
        plain_text_response = strip_markdown_formatting(response)
        char_count = len(plain_text_response)

        # Calculate percentage of limit
        char_limit = section_data.get('char_limit', 10000)
        char_percentage = (char_count / char_limit) * 100

        # Determine if over limit
        over_limit = char_count > char_limit

        # Check for placeholder text that needs completion
        needs_completion = '[NEEDS TO BE COMPLETED]' in markdown_content or '[TO BE COMPLETED]' in markdown_content

        output[section_key] = {
            'title': section_data['title'],
            'file': section_data['file'],
            'question': strip_markdown_formatting(question),
            'markdown': markdown_content,
            'plainText': plain_text_response,  # Only the response, not the question
            'charCount': char_count,
            'charLimit': char_limit,
            'charPercentage': round(char_percentage, 1),
            'overLimit': over_limit,
            'needsCompletion': needs_completion,
            'status': 'needs_input' if (over_limit or needs_completion) else 'complete',
            'warning': 'Over character limit!' if over_limit else ('Needs completion' if needs_completion else None)
        }

    return output


def main():
    """Main function to build responses content."""
    print("Building responses content...")

    responses = process_responses()

    # Write to JavaScript file
    js_content = f"""// Auto-generated by build_responses_content.py
// DO NOT EDIT MANUALLY

const responsesData = {json.dumps(responses, indent=2)};
"""

    output_path = Path('docs/responses_data.js')
    output_path.write_text(js_content)

    print(f"✅ Generated {output_path}")
    print(f"✅ Processed {len(responses)} response files")

    # Print summary
    print("\nCharacter Count Summary:")
    for key, data in responses.items():
        status_icon = "✅" if data['charCount'] <= 10000 else "⚠️"
        print(f"{status_icon} {data['title']}: {data['charCount']:,} / 10,000 chars ({data['charPercentage']}%)")


if __name__ == '__main__':
    main()
